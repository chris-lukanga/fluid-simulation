#version 430 core

layout(local_size_x = 256) in;

struct Particle {
    vec4 pos_radius; // xy = position, w = radius (mass)
    vec4 velocity;
    vec4 color;
};

layout(std430, binding = 0) buffer Particles {
    Particle particles[];
};

uniform float deltaTime;
uniform vec2 dimensions;
uniform float gravity;     // We can use this as the Gravitational Constant (G)
uniform int numParticles;

// 0.5 = bouncy walls, 1.0 = no energy loss
float wallDamping = 0.5; 

// Prevents force from exploding to infinity when distance is near zero
float softeningSq = 100.0; 

void main()
{
    uint index = gl_GlobalInvocationID.x;
    if (index >= uint(numParticles)) return;

    Particle p = particles[index];
    vec2 acceleration = vec2(0.0);

    // ---------------------------------------------------------
    // 1. N-BODY GRAVITY LOOP
    // ---------------------------------------------------------
    // Every particle pulls every other particle
    for(int i = 0; i < numParticles; i++) {
        if (i == index) continue; // Don't attract yourself

        Particle other = particles[i];
        
        vec2 direction = other.pos_radius.xy - p.pos_radius.xy;
        float distSq = dot(direction, direction);
        
        // Physics Formula: F = (G * m1 * m2) / r^2
        // Acceleration:    a = F / m1 
        // Therefore:       a = (G * m2) / r^2
        
        // We use radius (.w) as a stand-in for mass
        float otherMass = other.pos_radius.w; 
        
        // Calculate force magnitude
        // We add softeningSq to distSq to prevent division by zero
        float force = 50* (gravity * otherMass) / (distSq + softeningSq);
        
        // Accumulate acceleration
        acceleration += normalize(direction) * force;
    }

    // Apply accumulated acceleration
    p.velocity.xy += acceleration * deltaTime;

    // ---------------------------------------------------------
    // 2. INTEGRATE
    // ---------------------------------------------------------
    p.pos_radius.xy += p.velocity.xy * deltaTime;

    // ---------------------------------------------------------
    // 3. BOUNDARY CHECKS (Keep them on screen)
    // ---------------------------------------------------------
    
    // Left
    if (p.pos_radius.x - p.pos_radius.w < -dimensions.x * 0.5) {
        p.pos_radius.x = -dimensions.x * 0.5 + p.pos_radius.w;
        p.velocity.x *= -wallDamping;
    }
    // Right
    if (p.pos_radius.x + p.pos_radius.w > dimensions.x * 0.5) {
        p.pos_radius.x = dimensions.x * 0.5 - p.pos_radius.w;
        p.velocity.x *= -wallDamping;
    }
    // Bottom
    if (p.pos_radius.y - p.pos_radius.w < -dimensions.y * 0.5) {
        p.pos_radius.y = -dimensions.y * 0.5 + p.pos_radius.w;
        p.velocity.y *= -wallDamping;
    }
    // Top
    if (p.pos_radius.y + p.pos_radius.w > dimensions.y * 0.5) {
        p.pos_radius.y = dimensions.y * 0.5 - p.pos_radius.w;
        p.velocity.y *= -wallDamping;
    }

    // Write back
    particles[index] = p;
}