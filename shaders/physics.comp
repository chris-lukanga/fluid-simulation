#version 430 core

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// ---------------------------------------------------------
// Structures & Buffers
// ---------------------------------------------------------
struct Particle {
    vec4 pos_radius; // x,y,z position, w radius
    vec4 velocity;   // x,y,z velocity, w unused
    vec4 color;      // rgba
};

layout(std430, binding = 0) buffer ParticlesBlock {
    Particle particles[];
};

layout(std430, binding = 1) buffer particles2Block {
    Particle particles2[];
};

layout(std430, binding = 3) buffer Screen {
    vec2 fields[];
};


// ---------------------------------------------------------
// Uniforms
// ---------------------------------------------------------
uniform float deltaTime;
uniform int   numParticles;
uniform float gravity;          // Global downward gravity
uniform float gravityConstant;  // Newtonian gravity (G)
uniform vec2  dimensions;
uniform int   numFields;
uniform float smoothingRadius = 100.0; // For gravity softening
float pushStrength = 0.9;    // Strength of the repulsive force to prevent sticking

// ---------------------------------------------------------
// Physics: Collision Resolution
// ---------------------------------------------------------
void resolveCollisions(inout vec2 pos, inout vec2 vel, float r, uint myIdx, float dt) {
    for (int j = 0; j < numParticles; ++j) {
        if (j == int(myIdx)) continue;

        Particle other = particles[j];
        vec2 otherPos = other.pos_radius.xy;
        float otherR  = other.pos_radius.w;

        vec2 delta = pos - otherPos;
        float distSq = dot(delta, delta);
        float combinedR = r + otherR;
        float combinedRSq = combinedR * combinedR;

        if (distSq >= combinedRSq || distSq < 1e-8) continue;

        float dist = sqrt(distSq);
        vec2 n = delta / dist;
        float penetration = combinedR - dist;

        // 1. Positional Correction
        const float slop = 0.001;
        float corr = max(0.0, penetration - slop) * 0.5;
        pos += n * corr;

        // 2. Velocity Response
        vec2 otherVel = other.velocity.xy;
        float vRel = dot(vel - otherVel, n);

        if (vRel < 0.0) {
            float restitution = 1.0; // Bounciness (1.0 = elastic)
            // Baumgarte stabilization (fix sinking)
            float beta = 0.2;
            float bias = -beta * max(0.0, penetration - slop) / dt;
            float jImpulse = -((1.0 + restitution) * vRel + bias) * 0.5;
            
            vel += jImpulse * n;
        }
    }
}

float smoothingKernel(float r, float dst){
    float value = max(0, r*r-dst*dst);
    return value*value*value;
}

void calculatePush(inout vec2 pos, inout vec2 vel, float r, uint myIdx, float dt)
{
    for (int j = 0; j < numParticles; ++j)
    {
        if (j == int(myIdx)) continue;

        Particle other = particles[j];
        vec2 diff = other.pos_radius.xy - pos;

        float distSq = dot(diff, diff);
        float hSq = smoothingRadius * smoothingRadius;

        if (distSq >= hSq || distSq < 1e-6)
            continue;

        float dist = sqrt(distSq);
        vec2 dir = diff / dist;

        float x = smoothingRadius - dist;

        // kernel gradient force
        float forceMagnitude = pushStrength * x * x;

        vel -= dir * forceMagnitude * dt;
    }
}


// ---------------------------------------------------------
// Physics: Boundary Checks
// ---------------------------------------------------------
void resolveBoundaries(inout vec2 pos, inout vec2 vel, float r) {
    float halfW = dimensions.x * 0.5;
    float halfH = dimensions.y * 0.5;
    float wallFriction = 1.0; // Dampens energy when hitting walls

    if (pos.x - r < -halfW) {
        pos.x = -halfW + r;
        vel.x = abs(vel.x) * wallFriction;
    } else if (pos.x + r > halfW) {
        pos.x = halfW - r;
        vel.x = -abs(vel.x) * wallFriction;
    }

    if (pos.y - r < -halfH) {
        pos.y = -halfH + r;
        vel.y = abs(vel.y) * wallFriction;
    } else if (pos.y + r > halfH) {
        pos.y = halfH - r;
        vel.y = -abs(vel.y) * wallFriction;
    }
}



// ---------------------------------------------------------
// MAIN
// ---------------------------------------------------------
void main() {
    uint idx = gl_GlobalInvocationID.x;
    if(idx >= uint(numParticles)) return;

    // 1. Setup
    Particle p = particles[idx];
    vec2 pos = p.pos_radius.xy;
    vec2 vel = p.velocity.xy;
    float r  = p.pos_radius.w;
    float dt = min(deltaTime, 0.016); // Cap dt to prevent explosion on lag spikes

    // 2. Forces
    
    // A. Global Downward Gravity
    vel.y -= gravity * dt;

    calculatePush(pos, vel, r, idx, dt);

    // 3. INTEGRATION (The Missing Step!)
    pos += vel * dt;

    // 4. Constraints
    resolveCollisions(pos, vel, r, idx, dt);
    resolveBoundaries(pos, vel, r);

    // 5. Write Back
    p.pos_radius.xy = pos;
    p.velocity.xy   = vel;
    particles2[idx] = p;
}