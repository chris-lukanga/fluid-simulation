#version 430 core

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// ---------------------------------------------------------
// Structures & Buffers
// ---------------------------------------------------------
struct Particle {
    vec4 pos_radius; // x,y,z position, w radius
    vec4 velocity;   // x,y,z velocity, w unused
    vec4 color;      // rgba
};

layout(std430, binding = 0) buffer ParticlesBlock {
    Particle particles[];
};

layout(std430, binding = 1) buffer particles2Block {
    Particle particles2[];
};

// ---------------------------------------------------------
// Uniforms
// ---------------------------------------------------------
uniform float deltaTime;
uniform int   numParticles;
uniform float gravity;           // Global downward gravity
uniform float gravityConstant;   // Newtonian gravity (G)
uniform vec2  dimensions;
uniform bool  bounce;

// ---------------------------------------------------------
// Helper: Load Particle
// ---------------------------------------------------------
Particle loadParticle(uint index) {
    return bounce ? particles[index] : particles2[index];
}

// ---------------------------------------------------------
// Helper: Write Particle
// ---------------------------------------------------------
void writeParticle(uint index, Particle p) {
    if (bounce) {
        particles2[index] = p;
    } else {
        particles[index] = p;
    }
}

// ---------------------------------------------------------
// Physics: Newtonian Gravity (Attraction)
// ---------------------------------------------------------
vec2 calculateGravitationalForce(vec2 pos, float r, uint myIdx) {
    vec2 totalAccel = vec2(0.0);
    float myMass = r * r * r; // Mass proportional to volume (r^3)

    for (int j = 0; j < numParticles; ++j) {
        if (j == int(myIdx)) continue;

        Particle other = loadParticle(j);
        vec2 otherPos = other.pos_radius.xy;
        float otherR  = other.pos_radius.w;
        
        vec2 delta = otherPos - pos;
        float distSq = dot(delta, delta);

        // Softening prevents division by zero / singularities
        const float softening = 10.0; 
        float softenedDistSq = distSq + softening * softening;

        float otherMass = otherR * otherR * otherR;
        
        // F = G * m1 * m2 / r^2
        // a = F / m1 = G * m2 / r^2
        float forceMagnitude = gravityConstant * otherMass / softenedDistSq;
        
        float dist = sqrt(distSq);
        if (dist > 1e-6) {
            totalAccel += (delta / dist) * forceMagnitude;
        }
    }
    return totalAccel;
}

// ---------------------------------------------------------
// Physics: Collision Resolution
// ---------------------------------------------------------
void resolveCollisions(inout vec2 pos, inout vec2 vel, float r, uint myIdx, float dt) {
    for (int j = 0; j < numParticles; ++j) {
        if (j == int(myIdx)) continue;

        Particle other = loadParticle(j);
        vec2 otherPos = other.pos_radius.xy;
        float otherR  = other.pos_radius.w;

        vec2 delta = pos - otherPos;
        float distSq = dot(delta, delta);
        float combinedR = r + otherR;
        float combinedRSq = combinedR * combinedR;

        if (distSq >= combinedRSq || distSq < 1e-8) continue;

        float dist = sqrt(distSq);
        vec2 n = delta / dist;
        float penetration = combinedR - dist;

        // 1. Positional Correction
        const float slop = 0.001;
        float corr = max(0.0, penetration - slop) * 0.5;
        pos += n * corr;

        // 2. Velocity Response
        vec2 otherVel = other.velocity.xy;
        float vRel = dot(vel - otherVel, n);

        if (vRel < 0.0) {
            float restitution = 1.0; 
            
            // Baumgarte stabilization (fix sinking)
            float beta = 0.2; 
            float bias = -beta * max(0.0, penetration - slop) / dt;

            float jImpulse = -((1.0 + restitution) * vRel + bias) * 0.5;
            vel += jImpulse * n;
        }
    }
}

// ---------------------------------------------------------
// Physics: Boundary Checks
// ---------------------------------------------------------
void resolveBoundaries(inout vec2 pos, inout vec2 vel, float r) {
    float halfW = dimensions.x * 0.5;
    float halfH = dimensions.y * 0.5;
    float wallFriction = 1.0;

    if (pos.x - r < -halfW) {
        pos.x = -halfW + r;
        vel.x = abs(vel.x) * wallFriction;
    } else if (pos.x + r > halfW) {
        pos.x = halfW - r;
        vel.x = -abs(vel.x) * wallFriction;
    }

    if (pos.y - r < -halfH) {
        pos.y = -halfH + r;
        vel.y = abs(vel.y) * wallFriction;
    } else if (pos.y + r > halfH) {
        pos.y = halfH - r;
        vel.y = -abs(vel.y) * wallFriction;
    }
}

// ---------------------------------------------------------
// MAIN
// ---------------------------------------------------------
void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= uint(numParticles)) return;

    // 1. Setup
    Particle p = loadParticle(idx);
    vec2 pos = p.pos_radius.xy;
    vec2 vel = p.velocity.xy;
    float r  = p.pos_radius.w;
    float dt = min(deltaTime, 0.016);

    // 2. Forces & Integration
    // Global Gravity
    vel.y -= gravity * dt; 
    
    // N-Body Gravity
    if (gravityConstant > 0.0) {
        vel += calculateGravitationalForce(pos, r, idx) * dt;
    }

    // Integrate Position
    pos += vel * dt;

    // 3. Constraints
    resolveCollisions(pos, vel, r, idx, dt);
    resolveBoundaries(pos, vel, r);

    // 4. Write Back
    p.pos_radius.xy = pos;
    p.velocity.xy   = vel;
    writeParticle(idx, p);
}